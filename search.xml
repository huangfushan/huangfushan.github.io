<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>（AST）抽象语法数 -- babel 插件</title>
      <link href="2021/07/24/babel/"/>
      <url>2021/07/24/babel/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p> <code>babel</code>是 <code>Javascript</code> 的编译语法器，确切来说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）。意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。</p><h2 id="抽象语法数（AST）"><a href="#抽象语法数（AST）" class="headerlink" title="抽象语法数（AST）"></a>抽象语法数（AST）</h2><p>这个处理过程中的每一步都涉及到创建或是操作抽象语法树，亦称 AST。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function square(n) &#123;</span><br><span class="line">  return n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序可以被表示成如下的一棵树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- FunctionDeclaration:</span><br><span class="line">  - id:</span><br><span class="line">    - Identifier:</span><br><span class="line">      - name: square</span><br><span class="line">  - params [1]</span><br><span class="line">    - Identifier</span><br><span class="line">      - name: n</span><br><span class="line">  - body:</span><br><span class="line">    - BlockStatement</span><br><span class="line">      - body [1]</span><br><span class="line">        - ReturnStatement</span><br><span class="line">          - argument</span><br><span class="line">            - BinaryExpression</span><br><span class="line">              - operator: *</span><br><span class="line">              - left</span><br><span class="line">                - Identifier</span><br><span class="line">                  - name: n</span><br><span class="line">              - right</span><br><span class="line">                - Identifier</span><br><span class="line">                  - name: n</span><br></pre></td></tr></table></figure><p>或是如下所示的 JavaScript Object（对象）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &quot;FunctionDeclaration&quot;,</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;square&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  params: [&#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;n&quot;</span><br><span class="line">  &#125;],</span><br><span class="line">  body: &#123;</span><br><span class="line">    type: &quot;BlockStatement&quot;,</span><br><span class="line">    body: [&#123;</span><br><span class="line">      type: &quot;ReturnStatement&quot;,</span><br><span class="line">      argument: &#123;</span><br><span class="line">        type: &quot;BinaryExpression&quot;,</span><br><span class="line">        operator: &quot;*&quot;,</span><br><span class="line">        left: &#123;</span><br><span class="line">          type: &quot;Identifier&quot;,</span><br><span class="line">          name: &quot;n&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        right: &#123;</span><br><span class="line">          type: &quot;Identifier&quot;,</span><br><span class="line">          name: &quot;n&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会留意到 AST 的每一层都拥有相同的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &quot;FunctionDeclaration&quot;,</span><br><span class="line">  id: &#123;...&#125;,</span><br><span class="line">  params: [...],</span><br><span class="line">  body: &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: &quot;Identifier&quot;,</span><br><span class="line">  name: ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: &quot;BinaryExpression&quot;,</span><br><span class="line">  operator: ...,</span><br><span class="line">  left: &#123;...&#125;,</span><br><span class="line">  right: &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：出于简化的目的移除了某些属性</p></blockquote><p>这样的每一层结构也被叫做 节点（Node）。 一个 AST 可以由单一的节点或是成百上千个节点构成。</p><h2 id="Babel-的处理步骤"><a href="#Babel-的处理步骤" class="headerlink" title="Babel 的处理步骤"></a>Babel 的处理步骤</h2><p>Babel 的三个主要处理步骤分别是： <strong>解析（parse）</strong>，<strong>转换（transform）</strong>，<strong>生成（generate）</strong>。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析步骤接收代码并输出 AST。 这个步骤分为两个阶段：**词法分析（Lexical Analysis） **和 语法分析（Syntactic Analysis）。</p><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>词法分析阶段把字符串形式的代码转换为 令牌（tokens） 流。<br>你可以把令牌看作是一个扁平的语法片段数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n * n;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 0, end: 1, loc: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; type: &#123; ... &#125;, value: &quot;*&quot;, start: 2, end: 3, loc: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 4, end: 5, loc: &#123; ... &#125; &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>每一个 type 有一组属性来描述该令牌：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#123;</span><br><span class="line">    label: &#39;name&#39;,</span><br><span class="line">    keyword: undefined,</span><br><span class="line">    beforeExpr: false,</span><br><span class="line">    startsExpr: true,</span><br><span class="line">    rightAssociative: false,</span><br><span class="line">    isLoop: false,</span><br><span class="line">    isAssign: false,</span><br><span class="line">    prefix: false,</span><br><span class="line">    postfix: false,</span><br><span class="line">    binop: null,</span><br><span class="line">    updateContext: null</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 AST 节点一样它们也有 start，end，loc 属性。</p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>语法分析阶段会把一个令牌流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。</p><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>转换步骤接收 AST 并对其遍历，在此过程对节点进行添加、更新、删除等操作。这个是 Babel 编译器 中最复杂的过程，也是插件将来要介入工作的部分。</p><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>代码生成步骤把最终（经过一系列转换后）的 AST 转成字符串形式的代码，同时还会创建 <a href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">源码映射</a><br>代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>想要转换 AST 你需要进行递归的树形遍历。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> babel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 commitizen 规范 git commit 提交说明</title>
      <link href="2021/06/09/commitizen/"/>
      <url>2021/06/09/commitizen/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Git 作为目前开源社区最为火热的分布式系统版本管理工具，当我们在提交代码之前，都是需要添加 <code>Commit message</code>（提交说明），否则就不允许提交。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>上面代码的 <code>-m</code> 参数，就是用来指定 <code>commit message</code>的。</p><p>如果一行不够，可以只执行 <code>git commit</code>，就会跳出文本编辑器，让你写多行。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>基本上，你写什么都行。<br><img src="https://hfscdn.vercel.app/blog/commitizen-0.png" alt="iamge"></p><p>我们先来看下平时提交的 <code>commmit</code> 日志，只是简单的说明本次提交的信息，如<br><img src="https://hfscdn.vercel.app/blog/commitizen-1.png" alt="iamge"></p><p>我们再来看下具有一定规范性的 <code>commit</code> 日志，是不是更加清晰明了，有了一定的规范，对提交类型做了区分。<br><img src="https://hfscdn.vercel.app/blog/commitizen-2.png" alt="image"></p><p>一般来说，<code>commit message</code> 应该清晰明了，说明本次提交的目的。</p><p>目前，社区有多种 Commit message 的写法规范。这种是 <a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Angular 规范</a>，<a href="https://zj-git-guide.readthedocs.io/zh_CN/latest/message/Angular%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E8%A7%84%E8%8C%83/">中文</a>。这是目前使用最广的写法，是比较合理和系统化，并且有配套的工具。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li>提供更多的历史信息，方便快速浏览。</li><li>可以过滤某些 <code>commit</code>（比如文档改动），便于快速查找信息。</li><li>可以直接从 <code>commit</code> 生成 <code>Change log</code>。</li></ul><h2 id="标准-Commit-Message-规范"><a href="#标准-Commit-Message-规范" class="headerlink" title="标准 Commit Message 规范"></a>标准 Commit Message 规范</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>每次提交可以包含页眉(<code>header</code>)、正文(<code>body</code>)和页脚(<code>footer</code>)。其中，<code>Header</code> 是必需的。</p><p>每次提交的信息不超过 <code>100</code> 个字符，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">commit f477xxxxxxxba558 (HEAD -&gt; master)</span><br><span class="line">Author: huangfushan &lt;xxxxxxxxx@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 4 15:48:29 2021 +0800</span><br><span class="line"></span><br><span class="line">    feat: 🎸 添加新功能</span><br><span class="line">    </span><br><span class="line">    新功能详情介绍</span><br><span class="line">    </span><br><span class="line">    BREAKING CHANGE: 🧨 footer</span><br></pre></td></tr></table></figure><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p> <code>Header</code> 部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和 <code>subject</code>（必需）。</p><ul><li><code>type</code> 用于说明 <code>commit</code> 的类别<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git cz</span><br><span class="line">? Select the type of change that you&#39;re committing: (Use arrow keys or type to search)</span><br><span class="line">❯ 💍  test:       Adding missing tests                                    &#x2F;&#x2F; 添加缺失的测试</span><br><span class="line">  🎸  feat:       A new feature                                           &#x2F;&#x2F; 新功能（feature）</span><br><span class="line">  🐛  fix:        A bug fix                                               &#x2F;&#x2F; bug 修复</span><br><span class="line">  🤖  chore:      Build process or auxiliary tool changes                 &#x2F;&#x2F; 构建过程或辅助工具更改</span><br><span class="line">  ✏️  docs:       Documentation only changes                              &#x2F;&#x2F; 文档</span><br><span class="line">  💡  refactor:   A code change that neither fixes a bug or adds a feature&#x2F;&#x2F; 重构（不修复错误,不添加功能的代码更改）</span><br><span class="line">  💄  style:      Markup, white-space, formatting, missing semi-colons... &#x2F;&#x2F; 标记、空格、格式、缺少分号</span><br><span class="line">  🎡  ci:         CI related changes                                      &#x2F;&#x2F; CI相关的变化</span><br><span class="line">  ⚡️  perf:       A code change that improves performance                 &#x2F;&#x2F; 提高性能的代码更改</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><code>scope</code>，用于说明 <code>commit</code> 影响的范围</li><li><code>subject</code> 是 commit 目的的简短描述，一般不超过50个字符。</li></ul><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p><code>Body</code> 部分是对本次 commit 的详细描述，可以分成多行</p><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p><code>Footer</code> 部分只用于两种情况。</p><ul><li>不兼容变动<br>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述</li><li>关闭 <code>Issue</code><br>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单个</span><br><span class="line">Closes #123</span><br><span class="line">&#x2F;&#x2F; 支持多个</span><br><span class="line">Closes #123, #245, #992</span><br></pre></td></tr></table></figure></li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>上诉 <code>commit</code> 规范看起来是不很麻烦，这里推荐使用一些开源的工具进行管理，我们先来看一下效果<br><img src="https://hfscdn.vercel.app/blog/commitizen-3.gif" alt="image"></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><h4 id="commitizen-–-自动生成合格的-commit-message"><a href="#commitizen-–-自动生成合格的-commit-message" class="headerlink" title="commitizen – 自动生成合格的 commit message"></a><code>commitizen</code> – 自动生成合格的 <code>commit message</code></h4><p><code>commitizen</code> 是一个撰写合格 <code>Commit message</code> 的工具，通过 <code>commitizen</code> 我们可以快速生成符合规范的 <code>commit message</code>，下面我们介绍下怎么在项目中使用。</p><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g commitizen</span><br></pre></td></tr></table></figure></li><li><p>在项目目录里，运行下面的命令，使其支持 <code>Angular</code> 的 <code>Commit message</code> 格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure><p>如果出现报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Attempting to initialize using the npm package cz-conventional-changelog</span><br><span class="line">Error: A previous adapter is already configured. Use --force to override</span><br></pre></td></tr></table></figure></li></ul><p>可以在指令后面加上 –force</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><h4 id="git-cz-–-插件全局安装"><a href="#git-cz-–-插件全局安装" class="headerlink" title="git-cz – 插件全局安装"></a><code>git-cz</code> – 插件全局安装</h4><p>安装<code>git-cz</code>工具，也可用快速生成符合规范的 <code>commit message</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g git-cz</span><br><span class="line">$ git-cz</span><br></pre></td></tr></table></figure><h2 id="生成-CHANGE-LOG"><a href="#生成-CHANGE-LOG" class="headerlink" title="生成 CHANGE LOG"></a>生成 CHANGE LOG</h2><p>如果需要生成发布记录，可以通过 <code>conventional-changelog-cli</code> 生成。一般情况下，生成的文档包括</p><ul><li>New features</li><li>Bug fixes</li><li>Breaking changes.</li></ul><p>其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g conventional-changelog-cli</span><br></pre></td></tr></table></figure><h3 id="修改-package-json"><a href="#修改-package-json" class="headerlink" title="修改 package.json"></a>修改 <code>package.json</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s&quot;,</span><br><span class="line">  &quot;changelog-all&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="生成-CHANGELOG-md"><a href="#生成-CHANGELOG-md" class="headerlink" title="生成 CHANGELOG.md"></a>生成 CHANGELOG.md</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm run changelog &#x2F;&#x2F; 不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。</span><br><span class="line">$ npm run changelog-all &#x2F;&#x2F; 生成所有发布的 Change log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 Lerna 实现多个软件包的管理</title>
      <link href="2021/06/02/lerna/"/>
      <url>2021/06/02/lerna/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>将大型代码仓库分割成多个独立版本化的软件包（package）对于代码共享来说非常有用。但是，如果某些更改 跨越了多个代码仓库的话将变得很 麻烦 并且难以跟踪，并且跨越多个代码仓库的测试将迅速变得非常复杂。<br>为了解决这些（以及许多其它）问题，某些项目会将 代码仓库分割成多个软件包（package），并将每个软件包存放到独立的代码仓库中。</p></blockquote><p><code>Lerna</code> 是一种工具，针对 使用 <code>git</code> 和 <code>npm</code> 管理多软件包代码仓库的工作流程进行优化。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --global lerna                    &#x2F;&#x2F; 全局安装 lerna</span><br><span class="line">git init hfs-lerna-test &amp;&amp; cd hfs-lerna-test  &#x2F;&#x2F; 创建文件夹， hfs-lerna-test 仅代表当前例子文件夹名</span><br><span class="line">lerna init                                    &#x2F;&#x2F; 初始化一个lerna项目结构，如果希望各个包使用单独版本号可以加 -i | --independent</span><br></pre></td></tr></table></figure><p>你的代码仓库目前应该是如下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- hfs-lerna-test&#x2F;</span><br><span class="line">  - packages&#x2F;</span><br><span class="line">  - package.json</span><br><span class="line">  - lerna.json</span><br></pre></td></tr></table></figure><h2 id="运作方式"><a href="#运作方式" class="headerlink" title="运作方式"></a>运作方式</h2><h3 id="Fixed-模式（默认）"><a href="#Fixed-模式（默认）" class="headerlink" title="Fixed 模式（默认）"></a>Fixed 模式（默认）</h3><p>固定模式，也就是我们初始化时默认采用的模式。该模式为单版本号，在根目录 <code>lerna.json</code> 中设置，该模式你可以理解为 ‘全量发布’，即任何一个模块更新了，当你在执行 <code>lerna publish</code> 发布时，所有的模块都会统一更新版本号。<code>Babel</code> 目前就是采用该模式。</p><h3 id="Independent-模式"><a href="#Independent-模式" class="headerlink" title="Independent 模式"></a>Independent 模式</h3><p><code>lerna init --independent</code></p><p>独立模式的 Lerna 项目允许维护者单独升级包版本，可以理解为’增量发布’。每次发布时，您都会收到有关已更改的每个包的提示，以指定它是补丁、次要、主要还是自定义更改。  </p><p>这种方式相对第一种来说，更灵活，只需将只需将 <code>lerna.json </code> 中的 <code>version</code> 键改成 <code>independent</code> 即可启用 <code>independent</code> 模式。</p><h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p><code>lerna create test-1</code><br><code>lerna create test-2</code></p><p>执行上面的命令后会在 <code>packages</code> 中创建对应的模块，并根据提示生成 <code>package.json</code></p><p><img src="https://hfscdn.vercel.app/blog/lerna-create.png" alt="hexo"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├── lerna.json</span><br><span class="line">├── package.json</span><br><span class="line">└── packages</span><br><span class="line">    └── test-1</span><br><span class="line">    ├── __tests__</span><br><span class="line">    │    └── test-1.test.js</span><br><span class="line">    ├── lib</span><br><span class="line">    │    └── test-1.js</span><br><span class="line">        ├── package.json</span><br><span class="line">        └── README.md</span><br><span class="line">    └── test-2</span><br><span class="line">    ├── __tests__</span><br><span class="line">    │    └── test-2.test.js</span><br><span class="line">    ├── lib</span><br><span class="line">    │    └── test-2.js</span><br><span class="line">        ├── package.json</span><br><span class="line">        └── README.md</span><br></pre></td></tr></table></figure><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><blockquote><ul><li>我们时常看到某些一类诸如 <code>@babel/runtime</code>、<code>@babel/preset-env</code>的依赖包，其中 <code>babel</code> 实际就是可以看成包组织作用域的意思，代指分将<code>babel</code>包分割成多个独立版本化的软件包（package）。</li><li><code>npm</code> 包前面加 <code>@</code>，代表 <code>scopes</code> 相关的包，可以理解为作用域(范围)包， <code>npm</code> 作用域的命名不是谁便就能用的，只有两种可以使用：自己的用户名、自己创建的组织名。</li><li>因此在 <code>test-1</code>、<code>test-2</code> 中，<code>package.json</code> 的 <code>name</code> 字段分别改成 <code>@hfs-lerna-test/test-1</code>,<code>@hfs-lerna-test/test-2</code>。</li></ul></blockquote><p>在仓库根目录执行指令安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lerna bootstrap</span><br></pre></td></tr></table></figure><p><code>lerna bootstrap</code>，会安装当前目录下所有定义在 <code>package.json</code> 中的依赖包。相当于给 <code>packages</code> 下的每个软件包执行 <code>npm install</code></p><p>如果 <code>test-2/package.json</code> 中引用了<code>test-1</code>的依赖，执行后将自动将其添加到依赖包中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">  &quot;@hfs-lerna-test&#x2F;test-1&quot;: &quot;0.0.1&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">└── test-2</span><br><span class="line">    ├── __tests__</span><br><span class="line">    │    └── test-2.test.js</span><br><span class="line">    ├── node_modules</span><br><span class="line">    │    └── @hfs-lerna-test&#x2F;test-1</span><br><span class="line">    ├── lib</span><br><span class="line">    │    └── test-2.js</span><br><span class="line">    ├── package.json</span><br><span class="line">    └── README.md</span><br></pre></td></tr></table></figure><h2 id="发布模块"><a href="#发布模块" class="headerlink" title="发布模块"></a>发布模块</h2><p><code>lerna publish</code></p><blockquote><ul><li>执行时会打 <code>Tag</code>，上传 <code>Github </code>,上传 <code>NPM</code>。</li><li>当我们执行 <code>lerna publish</code> 命令时，可能会报错，<code>lerna publish</code> 常见错误见 <a href="#lerna-publish-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B">常见错误类型</a></li></ul></blockquote><ul><li><code>lerna publish</code> 本质上还是执行 <code>npm publish</code>，那么我们首先需要在 <code>npm</code> 仓库上注册用户，以及推送代码到远程 <code>github</code> 仓库。</li></ul><p><img src="https://hfscdn.vercel.app/blog/lerna-publish.png" alt="hexo"></p><ul><li><p>注意</p><ul><li><p><code>npm publish</code> 默认发布私有包，想要发布公共包必须使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --acsess&#x3D;public</span><br></pre></td></tr></table></figure></li><li><p>复制代码也可以在 <code>packages</code> 下的每个软件包的 <code>package.json</code> 中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;access&quot;: &quot;public&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="推动远程"><a href="#推动远程" class="headerlink" title="推动远程"></a>推动远程</h3><ul><li>登录 <a href="https://github.com/">Github</a></li><li>创建代码仓库，如：<code>git@github.com:&lt;username&gt;/hfs-lerna-test.git</code></li><li>提交代码，推送到指定远程仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:&lt;username&gt;&#x2F;hfs-lerna-test.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure></li></ul><h3 id="登录-npm-账户"><a href="#登录-npm-账户" class="headerlink" title="登录 npm 账户"></a>登录 npm 账户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看是否登录</span><br><span class="line">npm whoami</span><br><span class="line"></span><br><span class="line"># 没有则登录 </span><br><span class="line">npm login</span><br><span class="line"></span><br><span class="line"># 输入 username password</span><br></pre></td></tr></table></figure><h3 id="【发布】使用非组织包方式"><a href="#【发布】使用非组织包方式" class="headerlink" title="【发布】使用非组织包方式"></a>【发布】使用非组织包方式</h3><p>使用非组织包方式，需要设置报名为当前 <code>npm</code> 账户名为前缀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm adduser</span><br><span class="line">Username: @hfs-lerna-test &#x2F;&#x2F; 自己的username</span><br><span class="line">Password:                 &#x2F;&#x2F; 密码</span><br></pre></td></tr></table></figure><h3 id="【发布】组织包-scope-packages-方式（推荐）"><a href="#【发布】组织包-scope-packages-方式（推荐）" class="headerlink" title="【发布】组织包 scope packages 方式（推荐）"></a>【发布】组织包 scope packages 方式（推荐）</h3><blockquote><p>上诉我们定义的 <code>@hfs-lerna-test</code>，即代表这里的 <code>scope</code> 为 <code>@hfs-lerna-test</code></p></blockquote><ul><li><p>在 npm 仓库中创建团队，登录 <a href="https://www.npmjs.com/">NPM</a><br><img src="https://hfscdn.vercel.app/blog/npm-home.png" alt="hexo"></p></li><li><p>将自己的账号添加到该团队组织中<br><img src="https://hfscdn.vercel.app/blog/npm-add-organization.png" alt="hexo"><br><img src="https://hfscdn.vercel.app/blog/npm-add-username.png" alt="hexo"></p></li><li><p>最后，可以开始愉快地 <code>lerna publish</code> 了</p></li></ul><h2 id="Lerna-更多命令"><a href="#Lerna-更多命令" class="headerlink" title="Lerna 更多命令"></a>Lerna 更多命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lerna init        &#x2F;&#x2F; 初始化</span><br><span class="line">lerna clean       &#x2F;&#x2F; 删除 node_modules</span><br><span class="line">lerna bootstrap   &#x2F;&#x2F; 安装依赖</span><br><span class="line">lerna list        &#x2F;&#x2F; 列出包名</span><br></pre></td></tr></table></figure><p><code>lerna</code> 的详细用法，请参考 <a href="https://lerna.js.org/">lerna</a>。</p><h2 id="lerna-publish-常见错误类型"><a href="#lerna-publish-常见错误类型" class="headerlink" title="lerna publish 常见错误类型"></a>lerna publish 常见错误类型</h2><p>如</p><ul><li><p>未推送远程仓库</p><blockquote><p>解决：创建 <code>Github</code> 远程仓库，绑定并推送远程。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lerna publish</span><br><span class="line">lerna ERR! ENOREMOTEBRANCH Branch &#39;master&#39; doesn&#39;t exist in remote &#39;origin&#39;.</span><br><span class="line">lerna ERR! ENOREMOTEBRANCH If this is a new branch, please make sure you push it to the remote first.</span><br></pre></td></tr></table></figure></li><li><p>401 npm 未登录</p><blockquote><p>解决：执行 <code>npm whoami</code> 查看是否 <code>NPM</code> 已登录，未登录添加账户或登录。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lerna publish</span><br><span class="line">lerna ERR! EWHOAMI Authentication error. Use &#96;npm whoami&#96; to troubleshoot.</span><br></pre></td></tr></table></figure></li><li><p>402 您必须注册私人包</p><blockquote><p>解决：当前发布的 <code>npm</code> 包是 <code>@</code> 类型为私人包，但是 <a href="https://www.npmjs.com/">NPM</a> 上不存在该包组织，或者该组织为公共包。<br>请变更包类型，或者通过共有包发布，详情见 <a href="#%E5%8F%91%E5%B8%83%E6%A8%A1%E5%9D%97">发布模块 - 注意</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lerna publish</span><br><span class="line">lerna ERR! E402 You must sign up for private packages</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>Scope</code> 包组织未找到</p><blockquote><p>当前发布的 <code>npm</code> 包是 <code>@</code> 类型，核对 scope 是否正确，需用自己的用户名、或者自己创建的团队组织名。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lerna ERR! E404 Scope not found</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> lerna </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态网站托管服务</title>
      <link href="2021/05/05/deploy/"/>
      <url>2021/05/05/deploy/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><a href="/2021/04/26/blog/">上篇文章</a> 介绍了在我们不注册域名、以及购买云服务器的基础上，利用现有的免费的云厂商托管平台搭建个人网站。并以 <code>Hexo </code> + <code>Github Pages</code> 为例，实现了个人博客的快速搭建和部署。</p></blockquote><p>接下来分享其他常见的几种静态网站托管服务。</p><p><a href="https://pages.github.com/">Github Pages</a> </p><blockquote><p>是 <code>GitHub</code> 提供的一个网页托管服务，于2008年推出。可以用于存放静态网页，包括博客、项目文档甚至整本书。</p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>Github 的东家是微软，Git 管理全部代码，永远不用担心文字丢失或者复原问题；</li><li>百度无法爬取存在 Github 上的网站内容；</li><li>自带域名可 https 访问，如 https://&lt;你的 GitHub 用户名&gt;.github.io</li><li>支持自定义域名</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法给自定义域名配置 SSL 证书</li><li>墙内访问速度缓慢</li><li>流量限制（每个月 100Gb）基本够用</li></ul><hr><p><a href="https://docs.gitlab.com/ee/README.html">GitLab Pages</a><br>同样跟 GitHub Pages 的功能一样，但是：</p><ul><li>自定义域名可配置 https，不过需要上传证书</li></ul><hr><p><a href="https://vercel.com/">Vercel</a>（推荐）</p><blockquote><p>之前也叫 <code>Zeit</code> 或 <code>now.sh</code> 是一家提供 <code>JAMStack</code>，静态网站托管的平台，支持自动从 <code>Github</code>，<code>GitLab</code>，<code>Bitbucket</code> 等仓库自动拉取代码。</p></blockquote><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>可以使用 CLI 上传代码，或者链接一个 Git 仓库</li><li>支持自动式构建，指定构建命令，最后把生成的静态网站的一站式服务平台</li><li>不仅提供静态网站托管，同时也支持托管 Node.js 服务</li><li>支持自定义域名且自定义域名支持一键开启 https，自动申请 SSL 证书（证书来自 Let’s Encrype）</li><li>数据通过 HTTP2 协议传输</li><li>提供 API</li></ul><hr><p><a href="https://coding.net/">Coding</a></p><blockquote><p>CODING 静态网站服务是 CODING 联合腾讯云 Serverless 团队，为开发者提供的便捷、稳定、高拓展性的静态网站资源托管服务。无需自建服务器，即可一键部署网站应用，将静态网站分发至全网节点，轻松为您的网站业务增添稳定、高并发、快速访问等能力。</p></blockquote><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p> CODING 网站托管服务支持 Jekyll、Hexo 等多种部署框架。静态资源的分发由 腾讯云对象存储 COS 和拥有多个边缘网点的 腾讯云内容分发网络 CDN 提供支持</p><ul><li>Coding 为腾讯代理，在国内的服务器较多， 速度比 GitHub Page 快很多</li><li>支持自定义域名<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li><li>在首次创建静态网站前，您必须先完成授权操作和实名认证</li><li>静态资源的分发由 腾讯云对象存储 COS 和拥有多个边缘网点的 腾讯云内容分发网络 CDN 提供支持，可能产生少量付费</li></ul><hr><p><a href="https://www.netlify.com/">Netlify</a></p><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul><li>可以使用 CLI 上传代码</li><li>支持自定义域名且自定义域名支持一键开启 https（证书来自 Let’s Encrype）</li><li>支持强制让用户通过 https 访问网站（开启后此功能后，http 的访问一律会 301 跳转到 https</li><li>支持自动构建</li><li>支持重定向（Redirects）和重写（Rewrites）功能</li><li>数据通过 HTTP2 协议传输</li><li>提供 webhooks 与 API<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4></li><li>会自动把静态资源上传到 cloudfront CDN，但国内有些地方访问 cloudfront 速度很慢或部分被墙</li><li>速度比 Vercel 慢</li></ul><hr><p><a href="https://support.atlassian.com/bitbucket-cloud/docs/publishing-a-website-on-bitbucket-cloud/">Bitbucket Cloud</a><br>跟 GitHub Pages 的功能一样，但是：</p><ul><li>无法自定义域名</li><li>能且只能通过 https 协议访问（http 协议会被跳转到 https 协议）</li><li>所有项目的静态网站代码都只能放在专门的站点仓库里（accountName.bitbucket.io），不能像 GitHub 那样可以在每个项目里用 gh-pages 分支保存文件</li></ul><hr><h4 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h4><blockquote><p>通过无服务器计算，将前端静态资源快速部署到云厂商提供的云平台进行托管，配置默认生成的域名，快速生成站点。需按量付费。<br>经测验实际费用甚微，或无。</p></blockquote><ul><li><a href="http://serverless-devs.com/">Serverless Devs 阿里云</a></li><li><a href="https://www.serverless.com/cn/">Serverless Framework 腾讯云</a><!-- - Serverless</li><li><a href="https://www.aliyun.com/product/cdn">内容分发网络CDN</a> + <a href="https://www.aliyun.com/product/oss">对象存储OSS</a></li><li><a href="https://www.aliyun.com/product/fc">阿里云函数计算FC</a> –&gt;</li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客 Hexo + Github Page</title>
      <link href="2021/04/26/blog/"/>
      <url>2021/04/26/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><blockquote><p>在传统认知里，搭建个人静态网站我们需要：</p></blockquote><ul><li>注册域名</li><li>购买云服务器</li><li>域名备案</li><li>构建静态网页</li><li>部署前端静态资源</li><li>DNS 解析</li></ul><blockquote><p>上诉方案作为技术小白或者初学者来说，上手较难，时间、金钱成本花费较大，不推荐。<br>我们探讨的是如何在低成本的基础上，利用市面上现有的成熟的博客框架，搭建属于我们自己的个人博客。</p></blockquote><h1 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h1><blockquote><p>为了帮助开发者快速搭建所需的网站，这里提供的几种目前市面上比较火的博客框架，可以帮助我们快速的生成所需的静态网页。</p></blockquote><ul><li><a href="https://hexo.io/zh-cn/docs/">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>Hexo的主题样式也有很多好看的，而且github都有star上万的。</li><li><a href="https://wordpress.org/">Wordpress</a> 是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。有着许多第三方开发的免费模板，安装方式简单易用。</li><li><a href="https://vuepress.vuejs.org/">Vuepress</a> 由两部分组成：一个以 Vue 驱动的主题系统的简约静态网站生成工具，和一个为编写技术文档而优化的默认主题。它是为了支持 Vue 子项目的文档需求而创建的。</li><li><a href="https://www.docusaurus.cn/">Docusaurus</a> 是一个静态网站生成器，基于 React 技术构建，编译成的是静态的 HTML css，支持 Markdown 语法。</li><li><a href="https://d.umijs.org/zh-CN">Dumi</a> 是一款为组件开发场景而生的文档工具，与 <a href="https://github.com/umijs/father">father</a> 一起为开发者提供一站式的组件开发体验，father 负责构建，而 dumi 负责组件开发及组件文档生成。</li></ul><h1 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h1><blockquote><p>当然部署方案有很多，在服务器不用自己搭建的的基础上，无非就是找到可以实现免费托管的云厂商进行托管前端静态资源，生成可供访问的域名。</p></blockquote><p>这里仅列出几种方案，供参考。</p><ul><li><a href="https://pages.github.com/">Github Pages</a></li><li><a href="https://vercel.com/">Vercel</a></li><li><a href="https://coding.net/">Coding</a></li><li>Serverless（无服务器，按量付费）<ul><li><a href="http://serverless-devs.com/">Serverless Devs 阿里云</a></li><li><a href="https://www.serverless.com/cn/">Serverless Framework 腾讯云</a></li></ul></li></ul><!-- - Serverless- [内容分发网络CDN](https://www.aliyun.com/product/cdn) + [对象存储OSS](https://www.aliyun.com/product/oss)- [阿里云函数计算FC](https://www.aliyun.com/product/fc) --><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><blockquote><p>上诉博客框架以及部署方案任选其一，下面仅以 <code>Hexo </code>  为例，做 <code>Github Pages</code> 部署方案的介绍，感兴趣可以自行了解其他框架的使用。</p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="https://nodejs.org/en/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul><p><img src="https://hfscdn.vercel.app/blog/node-git-version.jpg" alt="iamge"></p><p>如图，如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往安装 <a href="#%E5%AE%89%E8%A3%85-Hexo">安装 Hexo</a>。</p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="- 安装 Git"></a>- 安装 Git</h3><p>Windows：下载并安装<a href="https://git-scm.com/download/win">Git</a><br>Mac：使用 <a href="https://brew.sh/">Homebrew</a>, <a href="https://www.macports.org/">MacPorts</a> 或者下载<a href="https://sourceforge.net/projects/git-osx-installer/">安装程序</a>。<br>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code><br>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="- 安装 Node.js"></a>- 安装 Node.js</h3><p>Node.js 为大多数平台提供了官方的<a href="https://nodejs.org/en/download/">安装程序</a>。对于中国大陆地区用户，可以前往<a href="https://npm.taobao.org/mirrors/node">淘宝 Node.js 镜像</a>下载。</p><p>其它的安装方法：</p><p>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者 <a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。<br>Mac：使用 <a href="https://brew.sh/">Homebrew</a> 或 <a href="https://www.macports.org/">MacPorts</a> 安装。<br>Linux（DEB/RPM-based）：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。<br>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 <a href="https://nodejs.org/en/download/package-manager/">指导</a>。</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="- 安装 Hexo"></a>- 安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 <code>npm</code> 安装 <code>Hexo</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="- 初始化"></a>- 初始化</h3><p>安装 <code>Hexo</code> 完成后，请执行下列命令，<code>Hexo</code> 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt; &#x2F;&#x2F; 初始化，如 hexo init blog</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install &#x2F;&#x2F; 可选，hexo 初始化默认会自动安装相关依赖</span><br><span class="line">hexo server &#x2F;&#x2F; 本地启动</span><br></pre></td></tr></table></figure><p><img src="https://hfscdn.vercel.app/blog/hexo-server.jpg" alt="hexo"><br>本地启动后，出现上即启动成功，浏览器登录图示 <code>http://localhost:4000</code> 地址即可本地访问。</p><p>更多配置信息见 <a href="https://hexo.io/zh-cn/docs/">Hexo 配置</a></p><h2 id="部署（Github-Page）"><a href="#部署（Github-Page）" class="headerlink" title="部署（Github Page）"></a>部署（Github Page）</h2><blockquote><p>上面已经把静态页面搭建完毕，接下来只需把代码部署到指定云厂商托管即可，以下提供三种部署方案，仅供参考。</p></blockquote><h3 id="Github-创建-repository"><a href="#Github-创建-repository" class="headerlink" title="- Github 创建 repository"></a>- Github 创建 repository</h3><p>在本教程中，我们 将 <code>Hexo</code> 博客部署到 <code>GitHub Pages</code> 上。</p><ul><li><a href="https://github.com/new">新建</a>一个 repository。如果你希望你的站点能通过 &lt;你的 GitHub 用户名&gt;.github.io 域名访问，你的 repository 应该直接命名为 &lt;你的 GitHub 用户名&gt;.github.io，如我的 Github 用户名为<code>huangfushan</code>, repository 即 <code>huangfushan.github.io</code>。</li><li>默认情况下不应该 public 目录将不会被推送到 repository 中，你应该检查 .gitignore 文件中是否包含 public 一行，如果没有请加上。</li><li>首次使用 <code>Github</code> 可能需要<a href="https://github.com/settings/ssh/new">绑定 SSH Key 密匙</a>，若无密匙见 <a href="/2021/04/25/git/">生成 SSH Key 密匙</a></li></ul><h3 id="Hexo-部署到-Github-Page"><a href="#Hexo-部署到-Github-Page" class="headerlink" title="- Hexo 部署到 Github Page"></a>- Hexo 部署到 Github Page</h3><ul><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save </span><br></pre></td></tr></table></figure></li><li>修改配置 _config.yml<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; # https:&#x2F;&#x2F;github.com&#x2F;你的 GitHub 用户名&#x2F;你的 GitHub 用户名.github.io.git</span><br></pre></td></tr></table></figure></li><li>部署<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate &#x2F;&#x2F; 编译</span><br><span class="line">hexo deploy &#x2F;&#x2F; 部署</span><br></pre></td></tr></table></figure><img src="https://hfscdn.vercel.app/blog/hexo-deploy.jpg" alt="deploy"></li><li>访问 https://你的 GitHub 用户名.github.io，如 <a href="https://huangfushan.github.io/">https://huangfushan.github.io</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 指令</title>
      <link href="2021/04/25/git/"/>
      <url>2021/04/25/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-指令"><a href="#Git-指令" class="headerlink" title="Git 指令"></a>Git 指令</h1><h2 id="设置用户名与邮箱"><a href="#设置用户名与邮箱" class="headerlink" title="设置用户名与邮箱"></a>设置用户名与邮箱</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;name&lt;自己的用户名&gt;&quot;</span><br><span class="line">git config --global user.email &quot;email&lt;自己的邮箱&gt;&quot;</span><br></pre></td></tr></table></figure><h2 id="生成-SSH-Key-密匙"><a href="#生成-SSH-Key-密匙" class="headerlink" title="生成 SSH Key 密匙"></a>生成 SSH Key 密匙</h2><blockquote><p>cd 到 ~/.ssh 目录下查看是否存在 id_rsa.pub 文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;.ssh</span><br><span class="line">$ ls</span><br><span class="line">  id_rsa id_rsa.pub</span><br></pre></td></tr></table></figure><blockquote><p>若不存在，执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;emai&lt;自己的邮箱&gt;&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 若涉及权限</span><br><span class="line">sudo ssh-keygen -t rsa -C &quot;emai&lt;自己的邮箱&gt;&quot; </span><br></pre></td></tr></table></figure><p>执行成功后执行 <code>cat ~/.ssh/id_rsa.pub</code>查看密匙，如下图。<br><img src="https://hfscdn.vercel.app/blog/ssh-key.jpg" alt="SSH KEY"></p><h2 id="绑定远程仓库"><a href="#绑定远程仓库" class="headerlink" title="绑定远程仓库"></a>绑定远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &quot;https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.git&quot; &#x2F;&#x2F; 初次绑定</span><br><span class="line">git remote set-url origin &quot;new repository&quot; &#x2F;&#x2F; 修改远程仓库</span><br></pre></td></tr></table></figure><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="- 创建分支"></a>- 创建分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="- 切换分支"></a>- 切换分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h4 id="拉取合并"><a href="#拉取合并" class="headerlink" title="- 拉取合并"></a>- 拉取合并</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git merge origin&#x2F;&lt;分支名&gt;</span><br><span class="line">或</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h4 id="添加暂存区"><a href="#添加暂存区" class="headerlink" title="- 添加暂存区"></a>- 添加暂存区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add . &#x2F;&#x2F; 添加所有到暂存区</span><br><span class="line">git add &lt;分支名&gt; &#x2F;&#x2F; 添加指定分支到暂存取</span><br></pre></td></tr></table></figure><h4 id="commit"><a href="#commit" class="headerlink" title="- commit"></a>- commit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交日志&quot; &#x2F;&#x2F; 仅暂存区代码 commit</span><br><span class="line">git commit -am &quot;&quot; &#x2F;&#x2F; 添加所有文件到暂存区，并 commit </span><br></pre></td></tr></table></figure><h4 id="提交远程"><a href="#提交远程" class="headerlink" title="- 提交远程"></a>- 提交远程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">&#x2F;&#x2F; 强制提交</span><br><span class="line">git push -f </span><br></pre></td></tr></table></figure><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="- 查看分支"></a>- 查看分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch  &#x2F;&#x2F; 查看本地</span><br><span class="line">git branch -a  &#x2F;&#x2F; 查看远程</span><br></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="- 删除分支"></a>- 删除分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt; &#x2F;&#x2F; 删除本地分支</span><br><span class="line">git branch -D &lt;分支名&gt; &#x2F;&#x2F; 强制删除本地分支</span><br><span class="line">git push origin -d &lt;分支名&gt; &#x2F;&#x2F; 删除远程</span><br></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;文件名&gt; &#x2F;&#x2F; 文件取消暂存区</span><br><span class="line">git reset HEAD &#x2F;&#x2F; 取消所有暂存取</span><br><span class="line">git reset --soft HEAD^ &#x2F;&#x2F; 撤销上一次 commit，并且可以重新 commit</span><br></pre></td></tr></table></figure><h3 id="本地暂存"><a href="#本地暂存" class="headerlink" title="本地暂存"></a>本地暂存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;需要暂存的文件&gt; &#x2F;&#x2F; 添加需要暂存的文件</span><br><span class="line">git stash commit &quot;暂存日志&quot; &#x2F;&#x2F; commit </span><br><span class="line">git stash list &#x2F;&#x2F; 查看所有暂存的 commit 记录</span><br><span class="line">git stash pop &#x2F;&#x2F; 提取最新一条暂存记录，提取指定某条有点问题，暂时不知道怎么提取</span><br></pre></td></tr></table></figure><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、会删除代码，commit 记录不保留</span><br><span class="line">git reset —-hard &lt;commit id&gt; &#x2F;&#x2F; 回滚到指定 commit</span><br><span class="line">git push -f &#x2F;&#x2F; 强制提交，远程仓库将回滚</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、会覆盖代码，commit 记录保留</span><br><span class="line">git revert &lt;commit id&gt; &#x2F;&#x2F; 用新的 commit 来回滚之前的 commit</span><br></pre></td></tr></table></figure><h1 id="使用-gitignore-无效的解决方法【已托管在git上的文件，需要保持到本地仓库】"><a href="#使用-gitignore-无效的解决方法【已托管在git上的文件，需要保持到本地仓库】" class="headerlink" title="使用.gitignore 无效的解决方法【已托管在git上的文件，需要保持到本地仓库】"></a>使用.gitignore 无效的解决方法【已托管在git上的文件，需要保持到本地仓库】</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached . &#x2F;&#x2F; 所有文件</span><br><span class="line">git rm -r --cached &lt;文件名&gt; &#x2F;&#x2F; 指定文件</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
